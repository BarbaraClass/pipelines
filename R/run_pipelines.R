#' Run multiple data pipelines
#'
#' Run multiple data pipelines. Currently, this produces separate .csv files but will eventually produce combined .csv files for all sites.
#'
#' @param path File path. Location of all folders for data owners. Note, the folders for each data owner must include the unique code of the data owner as seen in `site_codes`.
#' @param siteID The three-letter code of sites to format as listed in `site_codes`.
#' @param speciesID The six-letter code of species to include as listed in `species_codes`. Note, this argument takes precedence over argument siteID (i.e., if a site doesn't have the requested species it will not be formatted.)
#' @param optional_variables Optional variables (generated by standard utility functions) to be included in the pipeline output. Either a list of variable names or 'all' (if all optional variables should be included). See Details for a full list of optional variables.
#' @param output_type Should the pipeline generate .csv files ('csv') or R objects ('R'). Default: R.
#' @param save TRUE/FALSE. Should the output be saved locally? This is only relevant where
#' `output_type` is 'R'. If output_type is 'csv'
#' 4 .csv files will be created in the save path (specified by `save_path` argument). If output_type is 'R'
#' and `save` is TRUE, an .RDS file will be created in the save path.
#' @param save_path Path where files will be saved if `save` is TRUE. By default, the save
#' path will be path/standard_format.
#' @param filename The file name of the saved file. No file extension is
#' needed, as this will differ depending on `output_type`. By default, file name is
#' "standard_format".
#'
#' @details Optional variables generated by standard utility functions:
#' \itemize{
#' \item \code{breedingSeason} [Brood_data]. The breeding season in which the brood was laid. See \code{\link{calc_season}} for more details.
#' \item \code{calculatedClutchType} [Brood_data]. The type of clutch as classified by strict decision rules. See \code{\link{calc_clutchtype}} for more details.
#' \item \code{nestAttemptNumber} [Brood_data]. The sequence of nesting attempts by a breeding pair in a season. See \code{\link{calc_nestattempt}} for more details.
#' \item \code{calculatedSex} [Individual_data]. The sex of an individual concluded from 'observedSex' in Capture_data. See \code{\link{calc_sex}} for more details.
#' \item \code{exactAge} [Capture_data]. The exact age of the bird in number of years since birth. Exact age can only be determined for individuals ringed as chicks. See \code{\link{calc_age}} for more details.
#' \item \code{minimumAge} [Capture_data]. The minimum age of the bird in number of years since birth/ringing. Minimum age can be determined for all individuals. See \code{\link{calc_age}} for more details.
#' }
#'
#' @return Generate .csv files or return an R list object with 4 items (version <=1.1) or 6 (version >=1.2) items.
#' @export
#'
#' @examples
#' \dontrun{
#'
#' #Create an R list of Harjavalta data
#' HAR_data <- run_pipelines(siteID = "HAR", speciesID = "PARMAJ", output_type = "R")
#'
#' }

run_pipelines <- function(path = choose_directory(),
                          siteID = NULL,
                          speciesID = NULL,
                          optional_variables = NULL,
                          output_type = "R",
                          save = FALSE,
                          save_path = NULL,
                          filename = "standard_format"){

  #Force choose_directory()
  force(path)

  if((output_type == "csv" | (output_type == "R" & save)) & is.null(save_path)){

    save_path <- paste(path, "standard_format", sep = "/")

    if(!any(grepl(pattern = "standard_format", x = list.dirs(path)))){

      dir.create(save_path)

    }

  }

  #If site is NULL use all sites
  if(is.null(siteID)){

    siteID <- site_codes$siteID

  }

  #Determine operating system
  OS <- tolower(utils::sessionInfo()$running)

  #Drop sites from Access-based primary data if running on Mac
  Access_sites <- c("HOG", "OOS", "VLI", "BUU", "LIE", "WAR", "WES", "AMM")

  if(grepl(pattern = 'mac', x = OS)){

    if(length(siteID[which(siteID %in% Access_sites)] > 0)){
      warning(paste0('Pipelines not run for the following sites due to OS incompatibility: ',
                    toString(siteID[which(siteID %in% Access_sites)]),
                    ". To obtain standard format data for these sites, please run on a Windows OS.")
              )
    }

    siteID <- siteID[which(!(siteID %in% Access_sites))]

  } else if(!grepl(pattern = 'mac|windows', x = OS)){

    stop(paste0('Operating system ', OS, ' not supported'))

  }

  if(length(siteID) == 0){

    stop(paste0('None of the selected pipeline(s) could not be run due to OS incompatibility. Please run on a Windows OS.'))

  }

  #Assign species for filtering
  if(is.null(speciesID)){

    speciesID <- species_codes$speciesID

  } else if(all(!speciesID %in% species_codes$speciesID)){

    stop("Species provided are not included in the pipelines. Please select from species listed in species_codes")

  }

  #Firstly, check if there are any cases where a requested site does not have any info on a given species
  missing_species <- site_species_combos %>%
    dplyr::filter(.data$siteID %in% {{siteID}}) %>%
    dplyr::group_by(.data$siteID) %>%
    dplyr::summarise(total_species = sum(.data$speciesID %in% {{speciesID}}))

  #If there are any with missing data, give a warning message
  if(any(missing_species$total_species == 0)){

    missing_species %>%
      dplyr::filter(total_species == 0) %>%
      purrr::pwalk(.l = list(.data$siteID),
                   .f = ~{

                     message(paste0('Dite ', ..1, ' has no information on the focal species and has been excluded.'))

                   })

  }

  #Now just work with those sites where the site and species are present
  site_species_subset <- site_species_combos %>%
    dplyr::filter(.data$siteID %in% {{siteID}} & .data$speciesID %in% {{speciesID}}) %>%
    dplyr::left_join(dplyr::select(site_codes, siteID, institutionID), by = "siteID") %>%
    dplyr::group_by(.data$institutionID) %>%
    dplyr::summarise(Species = list(c(unique(speciesID))),
                     Sites = list(c(unique(siteID))))

  #Find the file path for each of the data owners of interest
  all_dirs <- list.dirs(path = path, full.names = TRUE, recursive = FALSE)
  all_dirs <- all_dirs[grepl(pattern = paste(site_species_subset$institutionID, collapse = "|"), all_dirs)]
  all_dirs <- gsub(pattern = "\\", replacement = "/", x = all_dirs, fixed = TRUE)

  #For each data owner, run the pipeline using the sites requested
  #Return R lists rather than generating .csv files
  R_objects <- purrr::pmap(.l = list(dirs = all_dirs,
                                     owner = site_species_subset$institutionID,
                                     sites = site_species_subset$Sites,
                                     species = site_species_subset$Species),
                           .f = function(dirs, owner, sites, species){

                             message(paste0('Running ', owner, ' pipeline'))

                           eval(parse(text = paste0('format_', owner, '(db = dirs, pop = sites, species = species, output_type = "R")')))

                             })

  #For each of the four tables, go through and combine the outputs
  #Add row numbers for each
  Brood_data <- purrr::map_df(.x = R_objects,
                              .f = ~{

                                .x$Brood_data

                              }) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Row = seq(1, dplyr::n())) %>%
    dplyr::select(Row, dplyr::everything())

  Capture_data <- purrr::map_df(.x = R_objects,
                                .f = ~{

                                  .x$Capture_data

                                }) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Row = seq(1, dplyr::n())) %>%
    dplyr::select(Row, dplyr::everything())

  Individual_data <- purrr::map_df(.x = R_objects,
                                   .f = ~{

                                     .x$Individual_data

                                   }) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Row = seq(1, dplyr::n())) %>%
    dplyr::select(Row, dplyr::everything())

  Location_data <- purrr::map_df(.x = R_objects,
                                 .f = ~{

                                   .x$Location_data

                                 }) %>%
    dplyr::ungroup() %>%
    dplyr::mutate(Row = seq(1, dplyr::n())) %>%
    dplyr::select(Row, dplyr::everything())

  if("Measurement_data" %in% names(R_objects)) {

    Measurement_data <- purrr::map_df(.x = R_objects,
                                      .f = ~{

                                        .x$Measurement_data

                                      }) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(row = seq(1, dplyr::n())) %>%
      dplyr::select(row, dplyr::everything())

  }

  if("Experiment_data" %in% names(R_objects)) {

    Experiment_data <- purrr::map_df(.x = R_objects,
                                     .f = ~{

                                       .x$Measurement_data

                                     }) %>%
      dplyr::ungroup() %>%
      dplyr::mutate(row = seq(1, dplyr::n())) %>%
      dplyr::select(row, dplyr::everything())

  }

  #If we want an R output, return a list with the 4 or 6 different data frames
  if(output_type == "R"){


    if("Measurement_data" %in% names(R_objects) & "Experiment_data" %in% names(R_objects)) { # v1.2

      output_object <- list(Brood_data = Brood_data,
                            Capture_data = Capture_data,
                            Individual_data = Individual_data,
                            Measurement_data = Measurement_data,
                            Location_data = Location_data,
                            Experiment_data = Experiment_data)
    } else { # v1.0 & v1.1

      output_object <- list(Brood_data = Brood_data,
                            Capture_data = Capture_data,
                            Individual_data = Individual_data,
                            Location_data = Location_data)

    }

    if(save){

      saveRDS(output_object, file = paste0(save_path, "/", filename, ".RDS"))

    }

    return(output_object)

  } else {

    message("Saving combined .csv files...")

    utils::write.csv(x = Brood_data, file = paste0(save_path, "/", filename, "_Brood_data.csv"), row.names = F)

    utils::write.csv(x = Capture_data, file = paste0(save_path, "/", filename, "_Capture_data.csv"), row.names = F)

    utils::write.csv(x = Individual_data, file = paste0(save_path, "/", filename, "_Individual_data.csv"), row.names = F)

    if("Measurement_data" %in% names(R_objects)) {utils::write.csv(x = Measurement_data, file = paste0(save_path, "/", filename, "_Measurement_data.csv"), row.names = F)}

    utils::write.csv(x = Location_data, file = paste0(save_path, "/", filename, "_Location_data.csv"), row.names = F)

    if("Experiment_data" %in% names(R_objects)) {utils::write.csv(x = Experiment_data, file = paste0(save_path, "/", filename, "_Experiment_data.csv"), row.names = F)}

    invisible(NULL)

  }

}
