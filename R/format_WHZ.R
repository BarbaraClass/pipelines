#' Construct standard format for data from Westerholz, Germany
#'
#' A pipeline to produce the standard format for the nest box population in Westerholz,
#' Germany, administered by Bart Kempenaers, Max Planck Institute for Biological Intelligence, Seewiesen, Germany.
#'
#' This section provides details on data management choices that are unique to this data. For a general description of the standard format please see \href{https://github.com/SPI-Birds/documentation/blob/master/standard_protocol/SPI_Birds_Protocol_v1.2.0.pdf}{here}.
#'
#' @inheritParams pipeline_params
#'
#' @return Generates either 6 .csv files or 6 data frames in the standard format.
#'
#' @export
#'

format_WHZ <- function(db = choose_directory(),
                       species = NULL,
                       site = NULL,
                       optional_variables = NULL,
                       path = ".",
                       output_type = "R") {

  # Force choose_directory() if used
  force(db)

  # Assign species for filtering
  if(is.null(species)){

    species <- species_codes$speciesID

  }

  # If all optional variables are requested, retrieve all names
  if(!is.null(optional_variables) & "all" %in% optional_variables) optional_variables <- names(unlist(unname(utility_variables)))

  # Record start time to provide processing time to the user
  start_time <- Sys.time()

  message("Importing primary data...")

  # Create a temporary in-memory RSQLite database to execute SQL queries on
  connection <- DBI::dbConnect(RSQLite::SQLite(), dbname = ":memory:")

  # Clean SQL files
  queries <- paste0(db, "\\WHZ_PrimaryData_",
                    c("BREEDING", "NESTS", "ADULTS", "CHICKS",
                      "SEX", "BOX_geoCoordinates"),
                    ".sql") %>%
    purrr::map(.f = ~ clean_query_WHZ(.x)) %>%
    unlist()

  # Execute SQL queries on database
  purrr::walk(.x = queries,
              .f = ~ DBI::dbExecute(connection, statement = .x))

  # BROOD DATA

  message("Compiling brood information...")

  Brood_data <- create_brood_WHZ(connection,
                                 optional_variables)




}

#' Create brood data table for Westerholz, Germany.
#'
#' Create brood data table in standard format for data from Westerholz, Germany.
#'
#' @param connection Connection the SQL database.
#' @param optional_variables A character vector of names of optional variables (generated by standard utility functions) to be included in the pipeline output.
#'
#' @return A data frame.
#'

create_brood_WHZ <- function(connection,
                             optional_variables) {

  Brood_data <- dplyr::tbl(connection, "BREEDING") %>%
    dplyr::rename(year = .data$year_,
                  femaleID = .data$IDfemale,
                  maleID = .data$IDmale,
                  observedClutchSize = .data$clutch,
                  observedBroodSize = .data$hatched,
                  observedNumberFledged = .data$fledged) %>%
    # Convert dates from character to datetime
    dplyr::mutate(dplyr::across(.cols = c(.data$firstEgg, .data$hatchDate,
                                          .data$lastHatchDate, .data$fledgeDate),
                                .fns = ~{

                                  lubridate::as_datetime(.x)

                                }),
                  # Create IDs
                  siteID = "WHZ",
                  # BroodID: year_nest box number_primary key
                  broodID = paste(.data$year, .data$box, .data$b_pk, sep = "_"),
                  # LocationID: institutionID_nest box number
                  locationID = paste0("WHZ_", .data$box),
                  # TODO: Check with data owner how to interpret experiment IDs
                  treatmentID = .data$experimental) %>%
    # TODO: Check on how to interpret second clutches (secondClutch == 1) when first clutches
    # are not recorded
    dplyr::mutate(observedClutchType = dplyr::case_when(.data$secondClutch == 0 ~ "first",
                                                         .data$secondClutch == 1 ~ "second"),
                  observedLayYear = as.integer(lubridate::year(.data$firstEgg)),
                  observedLayMonth = as.integer(lubridate::month(.data$firstEgg)),
                  observedLayDay = as.integer(lubridate::day(.data$firstEgg)),
                  observedHatchYear = as.integer(lubridate::year(.data$hatchDate)),
                  observedHatchMonth = as.integer(lubridate::month(.data$hatchDate)),
                  observedHatchDay = as.integer(lubridate::day(.data$hatchDate)),
                  observedFledgeYear = as.integer(lubridate::year(.data$fledgeDate)),
                  observedFledgeMonth = as.integer(lubridate::month(.data$fledgeDate)),
                  observedFledgeDay = as.integer(lubridate::day(.data$fledgeDate))) %>%
    # Above code is interpreted as SQL (for quicker run-time)
    # Force computation of the database query to run the remaining code
    dplyr::collect()

  output <- Brood_data %>%
    # If femaleID & maleID differ from expected format, set to NA
    # Ensure that individuals are unique:
    # add institutionID as prefix to femaleID & maleID
    dplyr::mutate(dplyr::across(.cols = c(.data$femaleID, .data$maleID),
                                .fns = ~{

                                  dplyr::case_when(stringr::str_detect(.x, "^[:upper:]{1}[:digit:]{1}[:upper:]{1}[:digit:]{4}$") ~ paste0("WHZ_", .x),
                                                   TRUE ~ NA_character_)

                                }),
                  # Set speciesID
                  speciesID = species_codes$speciesID[species_codes$speciesCode == "10002"]) %>%
    # Add optional variables
    {if("breedingSeason" %in% optional_variables) calc_season(data = ., season = .data$year) else .} %>%
    {if("calculatedClutchType" %in% optional_variables) calc_clutchtype(data = ., na.rm = FALSE, protocol_version = "1.2") else .} %>%
    {if("nestAttemptNumber" %in% optional_variables) calc_nestattempt(data = ., season = .data$breedingSeason) else .}

  return(output)

}


#' Clean syntax in SQL files
#'
#' WHZ primary data are stored in a series of SQL files, which contain redundant lines and syntax that is not correctly interpreted when reading into R. To execute the SQL statements, we first clean the SQL syntax.
#'
#' @param path Location of the SQL file.
#'
#' @return A list of characters with one element for each SQl statement.
#'
#' @example
#' \dontrun{
#' clean_query_WHZ("~/BREEDING.sql")
#' }
#'

clean_query_WHZ <- function(path){

  # Read lines from SQL file, and clean SQL query
  queries <- readLines(path) %>%
    # Remove metadata, comments
    stringr::str_remove_all("--.*$") %>%
    stringr::str_remove_all("/\\*.*?\\*/;") %>%
    stringr::str_remove_all("\\\\'") %>%
    stringr::str_remove_all("COMMENT.*(?=\\,)") %>%
    stringr::str_remove_all("unsigned")

  clean_queries <- purrr::map(.x = queries,
                              .f = ~{

                                # Set primary key
                                dplyr::case_when(stringr::str_detect(.x, "NOT NULL AUTO_INCREMENT") ~ paste0("`", stringr::str_extract(.x, pattern = "(?<=[`]).*(?=[`])"), "`"," INTEGER PRIMARY KEY AUTOINCREMENT,"),
                                                 stringr::str_detect(.x, "NOT NULL DEFAULT 0") ~ paste0("`", stringr::str_extract(.x, pattern = "(?<=[`]).*(?=[`])"), "`", " INTEGER PRIMARY KEY,"),
                                                 stringr::str_detect(.x, "PRIMARY KEY") ~ "",
                                                 # Remove additional keys
                                                 stringr::str_detect(.x, "KEY") ~ "",
                                                 # Remove table lock statements
                                                 stringr::str_detect(.x, "LOCK") ~ "",
                                                 stringr::str_detect(.x, "^\\)") ~ ");",
                                                 stringr::str_detect(.x, "--[^\r\n]*") ~ "",
                                                 stringr::str_detect(.x, "/\\*.*?\\*/") ~ "",
                                                 TRUE ~ .x)

                              }) %>%
    purrr::discard(~ .x == "")

  # Split by statement
  output <- purrr::map(.x = split(clean_queries, cumsum(stringr::str_detect(clean_queries,
                                                                            "^[:upper:]+"))),
                       .f = ~{

                         unlist(.x) %>%
                           stringr::str_c(collapse = " ") %>%
                           # Remove line breaks, tabs, etc.
                           stringr::str_replace_all("[\r\n\t\f\v]", " ") %>%
                           # Remove redundant white space
                           stringr::str_replace_all(" +", " ") %>%
                           # Remove redundant commas
                           stringr::str_replace_all(", +(?=\\))", " ")

                       })

  return(output)

}

#----------------------#
# TODO: How to deal with experimental IDs? Is there missing experimental data?
# TODO: Check how to interpret clutch type (secondClutch). What if no first clutch is recorded prior to second clutch in same box?
