#'Construct standard format for data from Askainen, Finland.
#'
#'A pipeline to produce the standard format for the hole nesting bird population in Askainen, Finland, administered by the University of Turku.
#'
#'This section provides details on data management choices that are unique to this data. For a general description of the standard protocol please see \href{https://github.com/SPI-Birds/documentation/blob/master/standard_protocol/SPI_Birds_Protocol_v1.2.0.pdf}{here}.
#'
#'@inheritParams pipeline_params
#'
#'\strong{Species:} We only include records for species with at least 50 broods throughout the study period: great tit, pied flycatcher, blue tit, coal tit, Eurasian wryneck, common redstart. The few records for common starling, European crested tit, and imprecise species (e.g., PARXXX) are excluded.
#'
#'\strong{Minimum & maximum lay & hatch dates}: Accuracy of lay and hatch date are given as categories: 1 = 0-1, 2 = 1-2, 3 = 2-3, 4 = inaccurate. Where error is a range, the more conservative error is used (i.e., 0-1 is recorded as 1). Cases listed as 'inaccurate' have an error of at least a week. Dates in these cases are highly inaccurate and shouldn't be considered for any phenology analysis.
#'
#'\strong{captureDate}:  No exact capture date is given. For adults we use the start of incubation (laying date + clutch size) as a proxy for capture date, or the laying date if clutch size is unknown.
#'
#'\strong{captureAlive, releaseAlive}: All individuals are assumed to be captured and released alive.
#'
#'\strong{captureRingNumber}: First captures of all individuals are assumed to be ringing events, and thus captureRingNumber is set to NA.
#'
#'\strong{ringStage}: Individuals that are not caught as a chick on the nest are assumed to be ringed as "subadult". This way, calculation of their minimum age is the most conservative.
#'
#'@return Generates either 6 .csv files or 6 data frames in the standard format.
#'@export
#'

format_ASK <- function(db = choose_directory(),
                       species = NULL,
                       site = NULL,
                       optional_variables = NULL,
                       path = ".",
                       output_type = "R") {

  # Force choose_directory() if used
  force(db)

  # Assign species for filtering
  if(is.null(species)){

    species <- species_codes$speciesID

  }

  # If all optional variables are requested, retrieve all names
  if(!is.null(optional_variables) & "all" %in% optional_variables) optional_variables <- names(unlist(unname(utility_variables)))

  # Record start time to provide processing time to the user
  start_time <- Sys.time()

  message("Importing primary data...")

  # BROOD DATA

  message("Compiling brood information...")

  Brood_data <- create_brood_ASK(db = db,
                                 species_filter = species,
                                 optional_variables = optional_variables)

  # CAPTURE DATA

  message("Compiling capture information...")

  Capture_data <- create_capture_ASK(db = db,
                                     brood_data = Brood_data,
                                     species_filter = species,
                                     optional_variables = optional_variables)

}


#' Create brood data table for Askainen, Finland.
#'
#' Create brood data table in standard format for data from Askainen, Finland.
#'
#' @param db Location of primary data from Askainen.
#' @param species_filter Species of interest. The 6 letter codes of all the species of
#'  interest as listed in the
#'  \href{https://github.com/SPI-Birds/documentation/blob/master/standard_protocol/SPI_Birds_Protocol_v1.2.0.pdf}{standard
#'  protocol}.
#' @param optional_variables A character vector of names of optional variables (generated by standard utility functions) to be included in the pipeline output.
#'
#' @return A data frame.
#'

create_brood_ASK <- function(db,
                             species_filter,
                             optional_variables) {

  message("Extracting brood data from paradox database...")

  # Pesat.DB contains the basic breeding parameters for each nest.
  broods <- extract_paradox_db(path = db, file_name = "ASK_PrimaryData_Pesat.DB") %>%
    # Rename columns to English (based on description provided by data owner)
    # -- Anro: Nest number in same box (1 = first nest in box, 2 = second nest in same box)
    # -- Ltar: unknown variables
    dplyr::rename(nestID = .data$Diario,
                  year = .data$Vuos,
                  locationID = .data$Nuro,
                  speciesID = .data$Laji,
                  nestAttemptBox = .data$Anro,
                  observedClutchType = .data$Pesa,
                  femaleID = .data$Naaras,
                  maleID = .data$Koiras,
                  observedLayDay = .data$Mpv,
                  observedLayMonth = .data$Mkk,
                  errorLayDay = .data$Mtar,
                  observedHatchDay = .data$Kpv,
                  observedHatchMonth = .data$Kkk,
                  errorHatchDay = .data$Ktar,
                  incubation = .data$Halku,
                  observedClutchSize = .data$Mulu,
                  observedBroodSize = .data$Kuor,
                  observedNumberFledged = .data$Lent,
                  reasonFailed = .data$Tsyy,
                  comments = .data$Lisatieto) %>%
    # Create IDs
    # Unique brood IDs: year_locationID_nestAttemptBox
    dplyr::mutate(broodID = paste(.data$year, .data$locationID, .data$nestAttemptBox, sep = "_"),
                  # Set species codes
                  # Note, rare species/codes are ignored and set to NA
                  # e.g., PARCRI, STUVUL, PARSPP, PARXXX
                  speciesID = dplyr::case_when(.data$speciesID == "FICHYP" ~ species_codes$speciesID[species_codes$speciesCode == "10003"],
                                               .data$speciesID == "PARMAJ" ~ species_codes$speciesID[species_codes$speciesCode == "10001"],
                                               .data$speciesID == "PARCAE" ~ species_codes$speciesID[species_codes$speciesCode == "10002"],
                                               .data$speciesID == "PARATE" ~ species_codes$speciesID[species_codes$speciesCode == "10005"],
                                               .data$speciesID == "PHOPHO" ~ species_codes$speciesID[species_codes$speciesCode == "10010"],
                                               .data$speciesID == "JYNTOR" ~ species_codes$speciesID[species_codes$speciesCode == "10011"],
                                               TRUE ~ NA_character_),
                  # If femaleID & maleID differ from expected format, set to NA
                  # Ensure that individuals are unique: add institutionID as prefix to femaleID & maleID
                  dplyr::across(.cols = c(.data$femaleID, .data$maleID),
                                .fns = ~ {

                                  dplyr::case_when(stringr::str_detect(string = .x,
                                                                       pattern = "^[:upper:]{1}[:digit:]{6}$") ~ paste0("ASK_", .x),
                                                                       TRUE ~ NA_character_)

                                }),
                  siteID = "ASK") %>%
    # Errors in lay date and hatch date are interpreted as symmetrical, so that
    # an error of, e.g., 2 results in a minimum lay date 2 days earlier than observed,
    # and a maximum lay date of 2 days later than observed.
    # Errors marked as NA, result in no known minimum/maximum lay & hatch dates.
    # Errors in category 4 (inaccurate) are interpreted as 1 week, resulting in a
    # minimum lay date 7 days earlier than observed, and a maximum lay date of
    # 7 days later than observed.
    dplyr::mutate(dplyr::across(.cols = c(.data$errorLayDay, .data$errorHatchDay),
                                .fns = ~ {

                                  dplyr::case_when(.x == 4 ~ 7L,
                                                   TRUE ~ .x)

                                }),
                  observedLayYear = .data$year,
                  observedLayDate = lubridate::make_date(year = .data$observedLayYear,
                                                         month = .data$observedLayMonth,
                                                         day = .data$observedLayDay),
                  minimumLayDate = dplyr::case_when(is.na(.data$errorLayDay) ~ as.Date(NA),
                                                   TRUE ~ .data$observedLayDate - .data$errorLayDay),
                  maximumLayDate = dplyr::case_when(is.na(.data$errorLayDay) ~ as.Date(NA),
                                                    TRUE ~ .data$observedLayDate + .data$errorLayDay),
                  minimumLayDay = as.integer(lubridate::day(.data$minimumLayDate)),
                  minimumLayMonth = as.integer(lubridate::month(.data$minimumLayDate)),
                  minimumLayYear = as.integer(lubridate::year(.data$minimumLayDate)),
                  maximumLayDay = as.integer(lubridate::day(.data$maximumLayDate)),
                  maximumLayMonth = as.integer(lubridate::month(.data$maximumLayDate)),
                  maximumLayYear = as.integer(lubridate::year(.data$maximumLayDate)),
                  observedHatchYear = .data$year,
                  observedHatchDate  = lubridate::make_date(year = .data$observedHatchYear,
                                                            month = .data$observedHatchMonth,
                                                            day = .data$observedHatchDay),
                  minimumHatchDate = dplyr::case_when(is.na(.data$errorHatchDay) ~ as.Date(NA),
                                                      TRUE ~ .data$observedHatchDate - .data$errorHatchDay),
                  maximumHatchDate = dplyr::case_when(is.na(.data$errorHatchDay) ~ as.Date(NA),
                                                      TRUE ~ .data$observedHatchDate + .data$errorHatchDay),
                  minimumHatchDay = as.integer(lubridate::day(.data$minimumHatchDate)),
                  minimumHatchMonth = as.integer(lubridate::month(.data$minimumHatchDate)),
                  minimumHatchYear = as.integer(lubridate::year(.data$minimumHatchDate)),
                  maximumHatchDay = as.integer(lubridate::day(.data$maximumHatchDate)),
                  maximumHatchMonth = as.integer(lubridate::month(.data$maximumHatchDate)),
                  maximumHatchYear = as.integer(lubridate::year(.data$maximumHatchDate)),
                  # Convert clutch type observed to our codes
                  # TODO: What does clutch type "0" mean?
                  observedClutchType = dplyr::case_when(.data$observedClutchType == 1 ~ "first",
                                                        .data$observedClutchType == 2 ~ "replacement",
                                                        .data$observedClutchType == 5 ~ "second",
                                                        TRUE ~ NA_character_))

    output <- broods %>%
      # Filter species and remove unknown species
      dplyr::filter(speciesID %in% {{species_filter}} & !is.na(speciesID)) %>%
      # Add optional variables
      {if("breedingSeason" %in% optional_variables) calc_season(data = .,
                                                                season = .data$year) else .} %>%
      {if("calculatedClutchType" %in% optional_variables) calc_clutchtype(data = .,
                                                                          na.rm = FALSE,
                                                                          protocol_version = "1.2") else .} %>%
      {if("nestAttemptNumber" %in% optional_variables) calc_nestattempt(data = .,
                                                                        season = .data$breedingSeason) else .}

    return(output)

}



#' Create capture data table for Askainen, Finland.
#'
#' Create capture data table in standard format for data from Askainen, Finland.
#'
#' @param db Location of primary data from Askainen.
#' @param brood_data Data frame. Output from \code{\link{create_brood_ASK}}.
#' @param species_filter Species of interest. The 6 letter codes of all the species of
#'  interest as listed in the
#'  \href{https://github.com/SPI-Birds/documentation/blob/master/standard_protocol/SPI_Birds_Protocol_v1.2.0.pdf}{standard
#'  protocol}.
#' @param optional_variables A character vector of names of optional variables (generated by standard utility functions) to be included in the pipeline output.
#'
#' @return A data frame.
#'

create_capture_ASK <- function(db,
                               brood_data,
                               species_filter,
                               optional_variables) {

  message("Extracting nest visit data from paradox database...")

  # Nest visits: contain info on nest stage & timing of ringing
  nest_visits <- extract_paradox_db(path = db, file_name = "ASK_PrimaryData_Visitit.DB") %>%
    # Rename columns to English (based on description provided by data owner)
    dplyr::select(nestID = .data$Diario,
                  year = .data$Vuos,
                  month = .data$Kk,
                  day = .data$Pv,
                  time = .data$Klo,
                  breedingPhase = .data$Tila) %>%
    dplyr::mutate(recordedBy = "LH") # See "Havno" column in Visitit.db

  # Brood data: contain info on broodID & timing of laying/hatching
  broods <- brood_data %>%
    dplyr::mutate(observedLayDate = lubridate::make_date(year = .data$observedLayYear,
                                                         month = .data$observedLayMonth,
                                                         day = .data$observedLayDay)) %>%
    dplyr::select(.data$nestID,
                  .data$broodID,
                  .data$speciesID,
                  .data$locationID,
                  .data$observedLayDate,
                  .data$observedHatchDate)

  # Chicks
  chick_visits <- nest_visits %>%
    # Retrieve chick ringing info per nest
    # breedingPhase P5 indicates a nest visit during which nestlings were ringed
    dplyr::filter(breedingPhase == "P5")

  message("Extracting chick ring numbers from paradox database...")

  chicks <- extract_paradox_db(path = db, file_name = "ASK_PrimaryData_Pulreng.DB") %>%
    # Rename columns to English (based on description provided by data owner)
    dplyr::select(nestID = .data$Diario,
                  ringSeries = .data$Rs,
                  firstRingNumber = .data$Mista,
                  lastRingNumber = .data$Mihin) %>%
    # Join in brood information using nestID
    dplyr::left_join(broods, by = "nestID") %>%
    # Join in chick ringing information using nestID
    dplyr::left_join(chick_visits, by = "nestID") %>%
    # Determine series of chick rings per nestID
    dplyr::mutate(individualID = purrr::map2(.x = .data$firstRingNumber,
                                             .y = .data$lastRingNumber,
                                             .f = ~ {

                                               # If first & last ring number are not NA,
                                               # determine ring series
                                               if(!is.na(.y)) {

                                                 ring_string <- paste0(.x, ":", .y)


                                               } else {

                                                 # If only first ring number is present,
                                                 # that ring number is the ring series
                                                 if(!is.na(.x)) {

                                                   ring_string <- .x

                                                   # If both first & last ring number are NA,
                                                   # set ring series to NA
                                                 } else {

                                                   ring_string <- NA_character_

                                                 }

                                               }

                                               # Parse text
                                               ring_series <- eval(parse(text = ring_string))

                                               # Pad zero if chick IDs started with 0
                                               output <-  stringr::str_pad(as.character(ring_series),
                                                                           width = nchar(.x),
                                                                           side = "left",
                                                                           pad = 0)

                                               # Set chick IDs to NA if the number of IDs is unlikely large
                                               # TODO: Check with data owner.
                                               # Three cases seem to have typos. NestIDs:
                                               # - 180348
                                               # - 181006
                                               # - 180985
                                               if(length(output) > 14) {

                                                 output <- NA_character_

                                               }

                                               return(output)

                                             })) %>%
    tidyr::unnest(cols = .data$individualID) %>%
    # Add ring series letter, if present
    dplyr::mutate(individualID = dplyr::case_when(!is.na(.data$ringSeries) ~ paste0(.data$ringSeries,
                                                                                    .data$individualID),
                                                  TRUE ~ .data$individualID),
                  # If individualID differs from expected format, set to NA
                  # Ensure that individuals are unique: add institutionID as prefix to individualID
                  individualID = dplyr::case_when(stringr::str_detect(string = .data$individualID,
                                                                      pattern = "^[:upper:]{1}[:digit:]{6}$") ~ paste0("ASK_",
                                                                                                                       .data$individualID),
                                                  TRUE ~ NA_character_)) %>%
    # Remove unknown individualIDs
    dplyr::filter(!is.na(.data$individualID)) %>%
    dplyr::rename(captureDay = .data$day,
                  captureMonth = .data$month,
                  captureYear = .data$year) %>%
    dplyr::mutate(captureTime = dplyr::na_if(paste0(stringr::str_pad(.data$time,
                                                                     width = 2,
                                                                     pad = "0",
                                                                     side = "left"),
                                                    ":00"),
                                             "NA:00"),
                  observedSex = NA_character_,
                  # Calculate chick age
                  age = "chick",
                  chickAge = as.integer(lubridate::make_date(year = .data$captureYear,
                                                             month = .data$captureMonth,
                                                             day = .data$captureDay) - .data$observedHatchDate)) %>%
    dplyr::select(.data$nestID,
                  .data$broodID,
                  .data$speciesID,
                  .data$individualID,
                  .data$observedSex,
                  .data$captureYear,
                  .data$captureMonth,
                  .data$captureDay,
                  .data$captureTime,
                  .data$recordedBy,
                  .data$locationID,
                  .data$age,
                  .data$chickAge)


  # Parents
  # Captures of parents only available through brood data
  parents <- brood_data %>%
    # Treat capture date of parents as the start of incubation (i.e., laying date + clutch size)
    # or at the start of laying when clutch size is unknown
    # TODO: Verify with data owner
    dplyr::mutate(observedLayDate = lubridate::make_date(year = .data$observedLayYear,
                                                         month = .data$observedLayMonth,
                                                         day = .data$observedLayDay),
                  captureDate = dplyr::case_when(!is.na(.data$observedClutchSize) ~ .data$observedLayDate + .data$observedClutchSize,
                                                 TRUE ~ .data$observedLayDate),
                  captureYear = .data$year,
                  captureMonth = as.integer(lubridate::month(.data$captureDate)),
                  captureDay = as.integer(lubridate::day(.data$captureDate)),
                  captureTime = NA_character_) %>%
    # Pivot information on females and males into rows
    tidyr::pivot_longer(cols = c(.data$femaleID, .data$maleID),
                        names_to = "sex",
                        values_to = "individualID") %>%
    # Remove unknown individualIDs
    dplyr::filter(!is.na(.data$individualID)) %>%
    dplyr::mutate(observedSex = dplyr::case_when(.data$sex == "femaleID" ~ "F",
                                                 .data$sex == "maleID" ~ "M"),
                  # TODO: parents assumed to be ringed as "subadult" - check with data owner
                  age = "subadult",
                  chickAge = NA_integer_,
                  recordedBy = "LH") %>%
    dplyr::select(.data$nestID,
                  .data$broodID,
                  .data$speciesID,
                  .data$individualID,
                  .data$observedSex,
                  .data$captureYear,
                  .data$captureMonth,
                  .data$captureDay,
                  .data$captureTime,
                  .data$recordedBy,
                  .data$locationID,
                  .data$age,
                  .data$chickAge)


  # Combine capture tables
  captures <- dplyr::bind_rows(parents, chicks) %>%
    dplyr::mutate(captureSiteID = "ASK",
                  releaseSiteID = .data$captureSiteID,
                  # TODO: Individuals are assumed to be captured alive, without replacing rings - verify
                  captureAlive = TRUE,
                  releaseAlive = TRUE,
                  capturePhysical = TRUE) %>%
    # Arrange chronologically for each individual
    dplyr::arrange(.data$individualID, .data$captureYear, .data$captureMonth, .data$captureDay) %>%
    dplyr::group_by(.data$individualID) %>%

    dplyr::mutate(captureRingNumber = dplyr::case_when(dplyr::row_number() == 1 ~ NA_character_,
                                                       TRUE ~ .data$individualID),
                  # All releases are assumed to be alive (also see releaseAlive), so no NAs in releaseRingNumber
                  releaseRingNumber = .data$individualID,
                  # Create captureID
                  captureID = paste(.data$individualID, 1:dplyr::n(), sep = "_")) %>%
    dplyr::ungroup() %>%
    # Filter species
    dplyr::filter(speciesID %in% {{species_filter}})

  # Add optional variables
  output <- captures %>%
    {if("exactAge" %in% optional_variables | "minimumAge" %in% optional_variables) calc_age(data = .,
                                                                                            Age = .data$age,
                                                                                            Year = .data$captureYear,
                                                                                            protocol_version = "1.2") %>%
        dplyr::select(dplyr::contains(c(names(captures), optional_variables))) else .}


  return(output)

}


#----------------------#
# TODO: Check clutch type ("Pesa") codes; what does 0 mean?
# TODO: Check chick ring series. Three nests must contain typos, because the resulting number of chicks is > 100.
# TODO: Check parent age
# TODO: Check whether individuals were only caught/released alive & physically
