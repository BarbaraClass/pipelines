#'Construct standard format for data from Askainen, Finland.
#'
#'A pipeline to produce the standard format for the hole nesting bird population in Askainen, Finland, administered by the University of Turku.
#'
#'This section provides details on data management choices that are unique to this data. For a general description of the standard protocol please see \href{https://github.com/SPI-Birds/documentation/blob/master/standard_protocol/SPI_Birds_Protocol_v1.2.0.pdf}{here}.
#'
#'@inheritParams pipeline_params
#'
#'@return Generates either 6 .csv files or 6 data frames in the standard format.
#'@export
#'

format_ASK <- function(db = choose_directory(),
                       species = NULL,
                       site = NULL,
                       optional_variables = NULL,
                       path = ".",
                       output_type = "R") {

  # Force choose_directory() if used
  force(db)

  # Assign species for filtering
  if(is.null(species)){

    species <- species_codes$speciesID

  }

  # If all optional variables are requested, retrieve all names
  if(!is.null(optional_variables) & "all" %in% optional_variables) optional_variables <- names(unlist(unname(utility_variables)))

  # Record start time to provide processing time to the user
  start_time <- Sys.time()

  message("Importing primary data...")

  # BROOD DATA

  message("Compiling brood information...")

  Brood_data <- create_brood_ASK(db = db,
                                 species_filter = species,
                                 optional_variables = optional_variables)


}


#' Create brood data table for Askainen, Finland.
#'
#' Create brood data table in standard format for data from Askainen, Finland.
#'
#' @param db Location of primary data from Askainen.
#' @param species_filter Species of interest. The 6 letter codes of all the species of
#'  interest as listed in the
#'  \href{https://github.com/SPI-Birds/documentation/blob/master/standard_protocol/SPI_Birds_Protocol_v1.2.0.pdf}{standard
#'  protocol}.
#' @param optional_variables A character vector of names of optional variables (generated by standard utility functions) to be included in the pipeline output.
#'
#' @return A data frame.
#'

create_brood_ASK <- function(db,
                             species_filter,
                             optional_variables) {

  message("Extracting brood data from paradox database...")

  broods <- extract_paradox_db(path = db, file_name = "ASK_PrimaryData_Pesat.DB") %>%
    # Rename columns to English (based on description provided by data owner)
    # TODO: What are "Anro" and "Ltar"?
    dplyr::rename(broodID = .data$Diario,
                  year = .data$Vuos,
                  locationID = .data$Nuro,
                  speciesID = .data$Laji,
                  observedClutchType = .data$Pesa,
                  femaleID = .data$Naaras,
                  maleID = .data$Koiras,
                  observedLayDay = .data$Mpv,
                  observedLayMonth = .data$Mkk,
                  errorLayDay = .data$Mtar,
                  observedHatchDay = .data$Kpv,
                  observedHatchMonth = .data$Kkk,
                  errorHatchDay = .data$Ktar,
                  incubation = .data$Halku,
                  observedClutchSize = .data$Mulu,
                  observedBroodSize = .data$Kuor,
                  observedNumberFledged = .data$Lent,
                  reasonFailed = .data$Tsyy,
                  comments = .data$Lisatieto) %>%
    # Create IDs
    # Unique brood IDs: year_locationID_broodID
    dplyr::mutate(broodID = paste(.data$year, .data$locationID, .data$broodID, sep = "_"),
                  # Set species codes
                  # Note, rare species/codes are ignored and set to NA
                  # e.g., STUVUL, PARSPP, PARXXX
                  speciesID = dplyr::case_when(.data$speciesID == "FICHYP" ~ species_codes$speciesID[species_codes$speciesCode == "10003"],
                                               .data$speciesID == "PARMAJ" ~ species_codes$speciesID[species_codes$speciesCode == "10001"],
                                               .data$speciesID == "PARCAE" ~ species_codes$speciesID[species_codes$speciesCode == "10002"],
                                               .data$speciesID == "PARATE" ~ species_codes$speciesID[species_codes$speciesCode == "10005"],
                                               .data$speciesID == "PHOPHO" ~ species_codes$speciesID[species_codes$speciesCode == "10010"],
                                               .data$speciesID == "JYNTOR" ~ species_codes$speciesID[species_codes$speciesCode == "10011"],
                                               .data$speciesID == "PARCRI" ~ species_codes$speciesID[species_codes$speciesCode == "10012"],
                                               TRUE ~ NA_character_),
                  # If femaleID & maleID differ from expected format, set to NA
                  # Ensure that individuals are unique: add institutionID as prefix to femaleID & maleID
                  dplyr::across(.cols = c(.data$femaleID, .data$maleID),
                                .fns = ~ {

                                  dplyr::case_when(stringr::str_detect(string = .x,
                                                                       pattern = "^[:upper:]{1}[:digit:]{6}$") ~ paste0("ASK_", .x),
                                                                       TRUE ~ NA_character_)

                                }),
                  siteID = "ASK") %>%
    # Errors in lay date and hatch date are interpreted as symmetrical, so that
    # an error of, e.g., 2 results in a minimum lay date 2 days earlier than observed,
    # and a maximum lay date of 2 days later than observed.
    # Errors marked as NA, result in no known minimum/maximum lay & hatch dates.
    dplyr::mutate(observedLayYear = .data$year,
                  observedLayDate = lubridate::make_date(year = .data$observedLayYear,
                                                         month = .data$observedLayMonth,
                                                         day = .data$observedLayDay),

                  minimumLayDate = dplyr::case_when(is.na(.data$errorLayDay) ~ as.Date(NA),
                                                   TRUE ~ .data$observedLayDate - .data$errorLayDay),
                  maximumLayDate = dplyr::case_when(is.na(.data$errorLayDay) ~ as.Date(NA),
                                                    TRUE ~ .data$observedLayDate + .data$errorLayDay),
                  minimumLayDay = as.integer(lubridate::day(.data$minimumLayDate)),
                  minimumLayMonth = as.integer(lubridate::month(.data$minimumLayDate)),
                  minimumLayYear = as.integer(lubridate::year(.data$minimumLayDate)),
                  maximumLayDay = as.integer(lubridate::day(.data$maximumLayDate)),
                  maximumLayMonth = as.integer(lubridate::month(.data$maximumLayDate)),
                  maximumLayYear = as.integer(lubridate::year(.data$maximumLayDate)),
                  observedHatchYear = .data$year,
                  observedHatchDate  = lubridate::make_date(year = .data$observedHatchYear,
                                                            month = .data$observedHatchMonth,
                                                            day = .data$observedHatchDay),
                  minimumHatchDate = dplyr::case_when(is.na(.data$errorHatchDay) ~ as.Date(NA),
                                                      TRUE ~ .data$observedHatchDate - .data$errorHatchDay),
                  maximumHatchDate = dplyr::case_when(is.na(.data$errorHatchDay) ~ as.Date(NA),
                                                      TRUE ~ .data$observedHatchDate + .data$errorHatchDay),
                  minimumHatchDay = as.integer(lubridate::day(.data$minimumHatchDate)),
                  minimumHatchMonth = as.integer(lubridate::month(.data$minimumHatchDate)),
                  minimumHatchYear = as.integer(lubridate::year(.data$minimumHatchDate)),
                  maximumHatchDay = as.integer(lubridate::day(.data$maximumHatchDate)),
                  maximumHatchMonth = as.integer(lubridate::month(.data$maximumHatchDate)),
                  maximumHatchYear = as.integer(lubridate::year(.data$maximumHatchDate)),
                  # Convert clutch type observed to our codes
                  # TODO: What does clutch type "0" mean?
                  observedClutchType = dplyr::case_when(.data$observedClutchType == 1 ~ "first",
                                                        .data$observedClutchType == 2 ~ "replacement",
                                                        .data$observedClutchType == 5 ~ "second",
                                                        TRUE ~ NA_character_))

    output <- broods %>%
      # Filter species and remove unknown species
      dplyr::filter(speciesID %in% {{species_filter}} & !is.na(speciesID)) %>%
      # Add optional variables
      {if("breedingSeason" %in% optional_variables) calc_season(data = .,
                                                                season = .data$year) else .} %>%
      {if("calculatedClutchType" %in% optional_variables) calc_clutchtype(data = .,
                                                                          na.rm = FALSE,
                                                                          protocol_version = "1.2") else .} %>%
      {if("nestAttemptNumber" %in% optional_variables) calc_nestattempt(data = .,
                                                                        season = .data$breedingSeason) else .}

    return(output)
}

#----------------------#
# TODO: Check column translations
# --- Brood: "Anro", "Ltar"
# TODO: Check clutch type ("Pesa") codes; what does 0 mean?
